import test from "ava";
import { EditableNode, Node, State, StatefulNode, Stream } from "./base";

// ============================
// ======= EditableNode =======
// ============================

test("[Base] [EditableNode] Factory functionality", (t) => {
    // TODO
});

test("[Base] [EditableNode] Property setting", (t) => {
    // TODO
});

test("[Base] [EditableNode] Property unsetting", (t) => {
    // TODO
});

test("[Base] [EditableNode] Updating node", (t) => {
    // TODO
});

test("[Base] [EditableNode] Replacing node", (t) => {
    // TODO
});

test("[Base] [EditableNode] Attaching a side effect", (t) => {
    // TODO
});

test("[Base] [EditableNode] Detaching a side effect", (t) => {
    // TODO
});

test("[Base] [EditableNode] Reaching action lifecycle hook", (t) => {
    // TODO
});

test("[Base] [EditableNode] Reaching action error hook", (t) => {
    // TODO
});

test("[Base] [EditableNode] Reaching side effect lifecycle hook", (t) => {
    // TODO
});

test("[Base] [EditableNode] Reaching side effect error hook", (t) => {
    // TODO
});

// =====================
// ======= State =======
// =====================

test("[Base] [State] Factory functionality", (t) => {
    // TODO
});

test("[Base] [State] Updating state", (t) => {
    // TODO
});

test("[Base] [State] Consuming state changes", (t) => {
    // TODO
});

// ====================
// ======= Node =======
// ====================

test("[Base] [Node] Factory functionality", (t) => {
    // TODO
});

test("[Base] [Node] Attaching action to node", (t) => {
    // TODO
});

test("[Base] [Node] Detaching action from node", (t) => {
    // TODO
});

test("[Base] [Node] Replacing node", (t) => {
    // TODO
});

test("[Base] [Node] Firing an action", (t) => {
    // TODO
});

test("[Base] [Node] Actions list contains all actions", (t) => {
    // TODO
});

test("[Base] [Node] Attaching side effect to node", (t) => {
    // TODO
});

test("[Base] [Node] Detaching side effect to node", (t) => {
    // TODO
});

test("[Base] [Node] Reaching action lifecycle hook", (t) => {
    // TODO
});

test("[Base] [Node] Reaching action error hook", (t) => {
    // TODO
});

test("[Base] [eNode] Reaching side effect lifecycle hook", (t) => {
    // TODO
});

test("[Base] [Node] Reaching side effect error hook", (t) => {
    // TODO
});

// ============================
// ======= StatefulNode =======
// ============================

test("[Base] [StatefulNode] Factory functionality", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Retrieving its state", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Retrieving the consumable state holder", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Setting its state", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Transforming its state", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Attaching a stateful side effect", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Detaching a stateful side effect", (t) => {
    // TODO
});

test("[Base] [StatefulNode] Firing a stateful side effect", (t) => {
    // TODO
});

// ======================
// ======= Stream =======
// ======================

test("[Base] [Stream] Factory functionality", (t) => {
    // TODO
});

test("[Base] [Stream] Adding element to the pool", (t) => {
    // TODO
});

test("[Base] [Stream] Consuming additions", (t) => {
    // TODO
});
